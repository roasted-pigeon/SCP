{% extends 'main/layout.html' %}
{% load static %}

{% block title %}
SCP DnD
{% endblock %}

{% block body %}
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Высота контейнера будет занимать всю доступную высоту */
        }

        #game-canvas {
            border: 1px solid #000;
            cursor: crosshair;
            margin-top: 20px; /* Добавляем небольшое отступание сверху для визуального разделения */
        }
    </style>
    <div class="container">
        <h1>SCP Foundation RPG Game Board</h1>
        <div class="form-group">
            <label for="grid-size">Размер сетки:</label>
            <select id="grid-size" class="form-control">
                <option value="20x20">20x20</option>
                <option value="30x30">30x30</option>
                <option value="40x40">40x40</option>
            </select>
        </div>
        <div class="form-group">
            <label for="num-rows">Количество строк:</label>
            <input type="number" id="num-rows" class="form-control" min="1" max="100" value="20">
        </div>
        <div class="form-group">
            <label for="num-cols">Количество столбцов:</label>
            <input type="number" id="num-cols" class="form-control" min="1" max="100" value="20">
        </div>
        <div class="form-group">
            <label for="fill-color">Цвет заполнения:</label>
            <input type="color" id="fill-color" class="form-control" value="#0000ff">
        </div>
        <div class="form-group">
            <label for="brush-size">Размер кисти: <span id="brush-size-display">1</span> пиксель</label>
            <input type="range" id="brush-size" class="form-control-range" min="1" max="20" value="1">
        </div>
        <div>
            <input type="radio" id="draw-mode" name="mode" value="draw" checked>
            <label for="draw-mode">Режим рисования</label>
        </div>
        <div>
            <input type="radio" id="fill-mode" name="mode" value="fill">
            <label for="fill-mode">Режим заполнения</label>
        </div>
        <canvas id="game-canvas"></canvas>
        <button id="clear-button" class="btn btn-danger mt-3">Очистить</button>
        <button id="save-button" class="btn btn-primary mt-3">Сохранить</button>
        <button id="load-button" class="btn btn-success mt-3">Загрузить</button>
    </div>

    <script>
        // JavaScript code for handling the game board functionality
        window.onload = function() {
            const canvas = document.getElementById('game-canvas');
            const context = canvas.getContext('2d');
            let cellSize = 1; // Размер клетки в пикселях
            let bigCellSize = 20; // Размер клетки в пикселях
            let numRows = document.getElementById('num-rows').value = {{ height }};
            let numCols = document.getElementById('num-cols').value = {{ width }};
            let brushSize = parseInt(document.getElementById('brush-size').value);
            let drawMode = true; // Флаг режима рисования (true - режим рисования, false - режим заполнения)
            let savedState = null; // Сохраненное состояние холста

            // Функция для изменения размера сетки
            function changeGridSize() {
                let newCellSize = parseInt(document.getElementById('grid-size').value.split('x')[0]);
                if (newCellSize !== bigCellSize) {
                    bigCellSize = newCellSize;
                    canvas.width = bigCellSize * numCols;
                    canvas.height = bigCellSize * numRows;
                    clearCanvas();
                }
            }

            document.getElementById('grid-size').addEventListener('change', changeGridSize);

            let fillColor = document.getElementById('fill-color').value; // Цвет заполнения по умолчанию

            // Функция для изменения цвета заполнения
            function changeFillColor() {
                fillColor = document.getElementById('fill-color').value;
            }

            document.getElementById('fill-color').addEventListener('change', changeFillColor);

            // Функция для изменения количества строк
            function changeNumRows() {
                const newNumRows = parseInt(document.getElementById('num-rows').value);
                if (newNumRows !== numRows) {
                    numRows = newNumRows;
                    canvas.height = bigCellSize * numRows;
                    clearCanvas();
                }
            }

            document.getElementById('num-rows').addEventListener('change', changeNumRows);

            // Функция для изменения количества столбцов
            function changeNumCols() {
                const newNumCols = parseInt(document.getElementById('num-cols').value);
                if (newNumCols !== numCols) {
                    numCols = newNumCols;
                    canvas.width = bigCellSize * numCols;
                    clearCanvas();
                }
            }

            document.getElementById('num-cols').addEventListener('change', changeNumCols);

            // Функция для изменения размера кисти
            function changeBrushSize() {
                brushSize = parseInt(document.getElementById('brush-size').value);
                document.getElementById('brush-size-display').textContent = brushSize;
            }

            document.getElementById('brush-size').addEventListener('input', changeBrushSize);

            // Функция для переключения режимов рисования
            function toggleMode(event) {
                drawMode = event.target.value !== 'fill';
            }

            document.getElementsByName('mode').forEach(function(element) {
                element.addEventListener('change', toggleMode);
            });

            // Установка размеров холста
            canvas.width = bigCellSize * numCols;
            canvas.height = bigCellSize * numRows;

            let isDrawing = false;

            // Функция для рисования следа мыши
            function drawTrail(x, y) {
                const halfBrushSize = brushSize / 2; // Половина размера кисти
                context.fillStyle = fillColor;

                if (drawMode) {
                    context.fillRect(x - halfBrushSize, y - halfBrushSize, brushSize, brushSize);
                } else {
                    const col = Math.floor(x / bigCellSize);
                    const row = Math.floor(y / bigCellSize);
                    context.fillRect(col * bigCellSize, row * bigCellSize, bigCellSize, bigCellSize);
                }
            }

            // Функция для определения координат клетки на основе позиции мыши
            function getCellCoordinates(mouseX, mouseY) {
                const rect = canvas.getBoundingClientRect();
                const col = Math.floor((mouseX - rect.left) / cellSize);
                const row = Math.floor((mouseY - rect.top) / cellSize);
                const x = col * cellSize{% comment %} + cellSize / 2{% endcomment %};
                const y = row * cellSize{% comment %} + cellSize / 2{% endcomment %};
                return { x, y, row, col };
            }

            // Обработчик события нажатия кнопки мыши
            canvas.addEventListener('mousedown', function(event) {
                isDrawing = true;
                const { x, y } = getCellCoordinates(event.clientX, event.clientY);
                drawTrail(x, y);
            });

            // Обработчик события перемещения мыши
            canvas.addEventListener('mousemove', function(event) {
                if (isDrawing) {
                    const { x, y } = getCellCoordinates(event.clientX, event.clientY);
                    drawTrail(x, y);
                }
            });

            // Обработчик события отпускания кнопки мыши
            canvas.addEventListener('mouseup', function(event) {
                isDrawing = false;
            });

            // Функция для очистки холста
            function clearCanvas() {
                context.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
            }

            // Функция для рисования сетки
            function drawGrid() {
                context.beginPath();
                for (let x = 0; x <= canvas.width; x += bigCellSize) {
                    context.moveTo(x, 0);
                    context.lineTo(x, canvas.height);
                }
                for (let y = 0; y <= canvas.height; y += bigCellSize) {
                    context.moveTo(0, y);
                    context.lineTo(canvas.width, y);
                }
                context.strokeStyle = '#ddd';
                context.stroke();
            }

            // Функция для сохранения состояния холста
            function saveCanvasState() {
                savedState = context.getImageData(0, 0, canvas.width, canvas.height);
            }

            document.getElementById('save-button').addEventListener('click', saveCanvasState);

            // Функция для загрузки сохраненного состояния холста
            function loadCanvasState() {
                if (savedState) {
                    context.putImageData(savedState, 0, 0);
                }
            }

            document.getElementById('load-button').addEventListener('click', loadCanvasState);

            // Функция для инициализации игрового поля
            function initGameBoard() {
                changeGridSize();
                clearCanvas();
            }

            document.getElementById('clear-button').addEventListener('click', clearCanvas);

            initGameBoard();
        }
    </script>
{% endblock %}
